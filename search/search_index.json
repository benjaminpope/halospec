{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"halospec","text":"<p>Halo Spectroscopy for JWST</p> <p>Contributors: Benjamin Pope</p>"},{"location":"#what-is-halospec","title":"What is halospec?","text":"<p>halospec - currently a placeholder - is a repository and package for halo spectroscopy of saturated sources in JWST/MIRI, using jax to implement Total Variation minimization (TV-min) by gradient descent. This is an evolution of the idea of halo photometry as implemented in halophot for K2.</p>"},{"location":"#installation","title":"Installation","text":"<p>halospec is hosted on PyPI (though this is currently a placeholder): the easiest way to install this is with </p> <pre><code>pip install halospec\n</code></pre> <p>You can also build from source. To do so, clone the git repo, enter the directory, and run</p> <pre><code>pip install .\n</code></pre> <p>We encourage the creation of a virtual enironment to run halospec to prevent software conflicts as we keep the software up to date with the lastest version of the core packages.</p>"},{"location":"#use-documentation","title":"Use &amp; Documentation","text":"<p>Documentation will be found here, though this is currently a placeholder. </p>"},{"location":"#collaboration-development","title":"Collaboration &amp; Development","text":"<p>We are always looking to collaborate and further develop this software! We have focused on flexibility and ease of development, so if you have a project you want to use halospec for, but it currently does not have the required capabilities, don't hesitate to email me and we can discuss how to implement and merge it! Similarly you can take a look at the <code>CONTRIBUTING.md</code> file.</p>"},{"location":"exploration-saturated/","title":"Halo Spectroscopy of Ceres","text":"<p>First, import everything we need.</p> In\u00a0[1]: Copied! <pre>import jax.numpy as np\nimport matplotlib.pyplot as plt\nimport numpy as onp\n\nimport jax \n\nfrom astropy.io import fits\n\nfrom glob import glob\n\nimport halospec.objectives as obj\n\nimport jaxopt\n\nfrom matplotlib.widgets import Slider\n\njax.config.update(\"jax_enable_x64\", True)\n\n%matplotlib inline\n</pre> import jax.numpy as np import matplotlib.pyplot as plt import numpy as onp  import jax   from astropy.io import fits  from glob import glob  import halospec.objectives as obj  import jaxopt  from matplotlib.widgets import Slider  jax.config.update(\"jax_enable_x64\", True)  %matplotlib inline  In\u00a0[2]: Copied! <pre>ls ../data/MAST_2024-07-05T0101/JWST\n</pre> ls ../data/MAST_2024-07-05T0101/JWST <pre>/Users/benpope/opt/anaconda3/envs/halospec/lib/python3.11/pty.py:89: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n  pid, fd = os.forkpty()\n</pre> <pre>jw01245-o004_t001_miri_ch1-shortmediumlong/\njw01245-o004_t001_miri_ch2-shortmediumlong/\njw01245-o004_t001_miri_ch3-shortmediumlong/\njw01245-o004_t001_miri_ch4-shortmediumlong/\njw01245-o021_t002_miri_ch1-shortmediumlong/\njw01245-o021_t002_miri_ch2-shortmediumlong/\njw01245-o021_t002_miri_ch3-shortmediumlong/\njw01245-o021_t002_miri_ch4-shortmediumlong/\njw01245-o024_t003_miri_ch1-shortmediumlong/\njw01245-o024_t003_miri_ch2-shortmediumlong/\njw01245-o024_t003_miri_ch3-shortmediumlong/\njw01245-o024_t003_miri_ch4-shortmediumlong/\njw01245040001_03102_00001_nrcblong/\n</pre> <p>Which sources did we get in this download?</p> In\u00a0[3]: Copied! <pre>ddir = '../data/MAST_2024-07-05T0101/JWST/'# unsaturated\nddir = '../data/MAST_2024-07-05T0131/JWST/' # saturated \ndatasets = glob(ddir+'*')\n# print(datasets)\n\n# figure out which targets are which\nfor j, dataset in enumerate(datasets):\n    try:\n        ifu = glob(dataset+'/*s3d*')\n        hdr = fits.getheader(ifu[0])\n        name = hdr['OBSLABEL']\n        print(j, name)\n    except:\n        print(j,'--')\n</pre> ddir = '../data/MAST_2024-07-05T0101/JWST/'# unsaturated ddir = '../data/MAST_2024-07-05T0131/JWST/' # saturated  datasets = glob(ddir+'*') # print(datasets)  # figure out which targets are which for j, dataset in enumerate(datasets):     try:         ifu = glob(dataset+'/*s3d*')         hdr = fits.getheader(ifu[0])         name = hdr['OBSLABEL']         print(j, name)     except:         print(j,'--') <pre>0 Hygiea/MIRI Background\n1 Ceres/MIRI\n2 --\n3 Didymos/MIRI\n4 Didymos/MIRI\n5 Didymos/MIRI Background\n6 Pallas/MIRI\n7 Ceres/MIRI\n8 Hygiea/MIRI Background\n9 Pallas/MIRI Background\n10 Hygiea/MIRI Background\n11 Ceres/MIRI Background\n12 Hygiea/MIRI\n13 Phaethon/MIRI\n14 Ceres/MIRI\n15 Didymos/MIRI\n16 Pallas/MIRI\n17 Didymos/MIRI Background\n18 Hygiea/MIRI\n19 Ceres/MIRI Background\n20 Phaethon/MIRI\n21 Pallas/MIRI Background\n22 Pallas/MIRI Background\n23 Phaethon/MIRI\n24 Ceres/MIRI Background\n25 Hygiea/MIRI\n26 Ceres/MIRI\n27 Phaethon/MIRI\n28 Hygiea/MIRI\n29 Ceres/MIRI Background\n30 Didymos/MIRI Background\n31 Didymos/MIRI\n32 Pallas/MIRI\n33 --\n34 Pallas/MIRI\n35 Didymos/MIRI Background\n36 Hygiea/MIRI Background\n37 Pallas/MIRI Background\n</pre> <p>Load Ceres.</p> In\u00a0[4]: Copied! <pre># dataset = ddir + 'jw01244-o024_t003_miri_ch4-shortmediumlong/'\n\nindex = 1 # Ceres\ndataset = datasets[index]+'/'\n# print(dataset)\n\nifu = glob(dataset+'*s3d*')\nprint('IFU Filename',ifu[0])\n# print(files)\n\nextracted = glob(dataset+'*x1d*')\nprint('Extracted Spectrum filename',extracted[0])\nextracted_hdr = fits.getheader(extracted[0],ext=1)\n\nhdu = fits.open(ifu[0])\ndata = fits.getdata(ifu[0])\ndata[~onp.isfinite(data)] = 0 # set NaNs to 0\n\nhdr = fits.getheader(ifu[0])\nname = hdr['OBSLABEL']\n\nextracted = glob(dataset+'*x1d*')\nextracted_hdr = fits.getheader(extracted[0],ext=1)\nextracted_data = fits.getdata(extracted[0],ext=1)\nwavels, ext_spec = extracted_data['WAVELENGTH'], extracted_data['FLUX']\next_spec /= onp.nanmedian(ext_spec)\n\nprint('\\nTarget:',name)\n</pre> # dataset = ddir + 'jw01244-o024_t003_miri_ch4-shortmediumlong/'  index = 1 # Ceres dataset = datasets[index]+'/' # print(dataset)  ifu = glob(dataset+'*s3d*') print('IFU Filename',ifu[0]) # print(files)  extracted = glob(dataset+'*x1d*') print('Extracted Spectrum filename',extracted[0]) extracted_hdr = fits.getheader(extracted[0],ext=1)  hdu = fits.open(ifu[0]) data = fits.getdata(ifu[0]) data[~onp.isfinite(data)] = 0 # set NaNs to 0  hdr = fits.getheader(ifu[0]) name = hdr['OBSLABEL']  extracted = glob(dataset+'*x1d*') extracted_hdr = fits.getheader(extracted[0],ext=1) extracted_data = fits.getdata(extracted[0],ext=1) wavels, ext_spec = extracted_data['WAVELENGTH'], extracted_data['FLUX'] ext_spec /= onp.nanmedian(ext_spec)  print('\\nTarget:',name) <pre>IFU Filename ../data/MAST_2024-07-05T0131/JWST/jw01244-o022_t001_miri_ch3-shortmediumlong/jw01244-o022_t001_miri_ch3-shortmediumlong_s3d.fits\nExtracted Spectrum filename ../data/MAST_2024-07-05T0131/JWST/jw01244-o022_t001_miri_ch3-shortmediumlong/jw01244-o022_t001_miri_ch3-shortmediumlong_x1d.fits\n\nTarget: Ceres/MIRI\n</pre> <p>Visualize a slice: what does one frame look like?</p> In\u00a0[5]: Copied! <pre># one frame\nfig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\n\ndata[data==np.nan] = 0\n\nax1.imshow(data[0,:,:])\nax1.set_title('Flux')\n\nax2.imshow(data[0,:,:]&gt;0)\nax2.set_title('Positive')\n\nax3.imshow(data[0,:,:]==0)\nax3.set_title('Zero')\n</pre> # one frame fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))  data[data==np.nan] = 0  ax1.imshow(data[0,:,:]) ax1.set_title('Flux')  ax2.imshow(data[0,:,:]&gt;0) ax2.set_title('Positive')  ax3.imshow(data[0,:,:]==0) ax3.set_title('Zero') Out[5]: <pre>Text(0.5, 1.0, 'Zero')</pre> <p>(Interactively visualize a slice)</p> In\u00a0[\u00a0]: Copied! <pre># %matplotlib widget \n# idx0 = 3\n# l = plt.imshow(data[idx0])\n\n# axidx = plt.axes([0.25, 0.01, 0.65, 0.03])\n# slidx = Slider(axidx, 'index', 0, 9, valinit=idx0, valfmt='%d')\n\n# def update(val):\n#     idx = slidx.val\n#     l.set_data(data[int(idx)])\n#     fig.canvas.draw_idle()\n    \n# slidx.on_changed(update)\n\n# plt.show()\n</pre> # %matplotlib widget  # idx0 = 3 # l = plt.imshow(data[idx0])  # axidx = plt.axes([0.25, 0.01, 0.65, 0.03]) # slidx = Slider(axidx, 'index', 0, 9, valinit=idx0, valfmt='%d')  # def update(val): #     idx = slidx.val #     l.set_data(data[int(idx)]) #     fig.canvas.draw_idle()      # slidx.on_changed(update)  # plt.show()  <p>What does the median frame look like?</p> In\u00a0[6]: Copied! <pre>%matplotlib inline\n\n# all frames\nfig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\n\nax1.imshow(onp.median(data,axis=0))\nax1.set_title('Flux')\n\nax2.imshow(onp.median(data,axis=0)&gt;0)\nax2.set_title('Positive')\n\nax3.imshow(onp.min(data,axis=0)==0)\nax3.set_title('Zero')\n</pre> %matplotlib inline  # all frames fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))  ax1.imshow(onp.median(data,axis=0)) ax1.set_title('Flux')  ax2.imshow(onp.median(data,axis=0)&gt;0) ax2.set_title('Positive')  ax3.imshow(onp.min(data,axis=0)==0) ax3.set_title('Zero') Out[6]: <pre>Text(0.5, 1.0, 'Zero')</pre> <p>So they are using zero-masking. That's good!</p> <p>Let's identify bad frames, and saturated / missing pixels.</p> In\u00a0[7]: Copied! <pre># ravel pixels\nravelled = np.reshape(data,(data.shape[0],data.shape[1]*data.shape[2]))\nplt.plot(onp.min(ravelled,axis=1)) # some frames are badly corrected?\n</pre> # ravel pixels ravelled = np.reshape(data,(data.shape[0],data.shape[1]*data.shape[2])) plt.plot(onp.min(ravelled,axis=1)) # some frames are badly corrected? Out[7]: <pre>[&lt;matplotlib.lines.Line2D at 0x2a1569a50&gt;]</pre> In\u00a0[8]: Copied! <pre># frame rejection\ngoodframes = onp.min(ravelled,axis=1)==0\n\n# pixel rejection\ngoodpix = onp.min(data,axis=0)&gt;0\n\n# censored data\nnewdata = data[:,goodpix]\nnewdata = newdata[goodframes]\n\nwavels, ext_spec = wavels[goodframes],ext_spec[goodframes]\nprint('Shape of censored data in spectra x spaxels:',newdata.shape)\n</pre> # frame rejection goodframes = onp.min(ravelled,axis=1)==0  # pixel rejection goodpix = onp.min(data,axis=0)&gt;0  # censored data newdata = data[:,goodpix] newdata = newdata[goodframes]  wavels, ext_spec = wavels[goodframes],ext_spec[goodframes] print('Shape of censored data in spectra x spaxels:',newdata.shape) <pre>Shape of censored data in spectra x spaxels: (2572, 920)\n</pre> <p>Now let's plot a selection of individual spectra, and their total and the pipeline extracted spectrum.</p> In\u00a0[9]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(1,2,figsize=(15.0,5.0))\nfor j in range(10):\n    spec = newdata[:,j]\n    ax1.plot(wavels,spec/onp.nanmedian(spec))\nax1.set_title('Individual Spaxel Spectra')\nax1.set_xlabel('Wavelength (\u03bcm)')\n    \nflat = onp.sum(newdata,axis=1)\nflat /= onp.nanmedian(flat)\nax2.plot(wavels,flat,label='Total')\nax2.plot(wavels,ext_spec,label='Pipeline')\nplt.legend()\n\nax2.set_title('Total')\nax2.set_xlabel('Wavelength (\u03bcm)')\n</pre> fig, (ax1, ax2) = plt.subplots(1,2,figsize=(15.0,5.0)) for j in range(10):     spec = newdata[:,j]     ax1.plot(wavels,spec/onp.nanmedian(spec)) ax1.set_title('Individual Spaxel Spectra') ax1.set_xlabel('Wavelength (\u03bcm)')      flat = onp.sum(newdata,axis=1) flat /= onp.nanmedian(flat) ax2.plot(wavels,flat,label='Total') ax2.plot(wavels,ext_spec,label='Pipeline') plt.legend()  ax2.set_title('Total') ax2.set_xlabel('Wavelength (\u03bcm)')  Out[9]: <pre>Text(0.5, 0, 'Wavelength (\u03bcm)')</pre> In\u00a0[10]: Copied! <pre>from jaxopt import LBFGS\nmake_spec = obj.make_spec\n</pre> from jaxopt import LBFGS make_spec = obj.make_spec In\u00a0[11]: Copied! <pre>spaxels = np.array(newdata).T # make it a jax array of the right shape\n</pre> spaxels = np.array(newdata).T # make it a jax array of the right shape In\u00a0[12]: Copied! <pre>%%time\n\n# TV-Min - minimize L1 norm of gradient - same as in halo\ntvmin = lambda x: obj.tv(x,1,spaxels) # not using lag so setting it to 1 by lambda function\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=tvmin, maxiter=100)\nres = solver.run(init_params)\ntv_params, state = res\n\ntv_final = make_spec(tv_params,spaxels)\n</pre> %%time  # TV-Min - minimize L1 norm of gradient - same as in halo tvmin = lambda x: obj.tv(x,1,spaxels) # not using lag so setting it to 1 by lambda function  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=tvmin, maxiter=100) res = solver.run(init_params) tv_params, state = res  tv_final = make_spec(tv_params,spaxels) <pre>CPU times: user 2.24 s, sys: 151 ms, total: 2.39 s\nWall time: 2.41 s\n</pre> <p>... and L2V-min, or maximum smoothness:</p> In\u00a0[13]: Copied! <pre>%%time\n\n# L2V-Min - minimize L2 norm of gradient, ie maximize smoothness\nl2vmin = lambda x: obj.l2v(x,1,spaxels) # not using lag so setting it to 1 by lambda function\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=l2vmin, maxiter=100)\nres = solver.run(init_params)\nl2v_params, state = res\n\nl2v_final = make_spec(l2v_params,spaxels)\n</pre> %%time  # L2V-Min - minimize L2 norm of gradient, ie maximize smoothness l2vmin = lambda x: obj.l2v(x,1,spaxels) # not using lag so setting it to 1 by lambda function  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=l2vmin, maxiter=100) res = solver.run(init_params) l2v_params, state = res  l2v_final = make_spec(l2v_params,spaxels) <pre>CPU times: user 1.59 s, sys: 117 ms, total: 1.7 s\nWall time: 1.68 s\n</pre> <p>And we can try OWL, for completeness' sake using all the original halo objectives:</p> In\u00a0[14]: Copied! <pre>%%time\n# OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective. \n# It doesn't seem to do especially well!\n\nowlvmin = lambda x: obj.owl(x,spaxels)\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=owlvmin, maxiter=100)\nres = solver.run(init_params)\nowl_params, state = res\n\nowl_final = make_spec(owl_params,spaxels)\n</pre> %%time # OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective.  # It doesn't seem to do especially well!  owlvmin = lambda x: obj.owl(x,spaxels)  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=owlvmin, maxiter=100) res = solver.run(init_params) owl_params, state = res  owl_final = make_spec(owl_params,spaxels) <pre>CPU times: user 3.01 s, sys: 134 ms, total: 3.14 s\nWall time: 3.15 s\n</pre> <p>Experimental Gaussian Process model:</p> In\u00a0[15]: Copied! <pre>%%time\n# GP log likelihood as objective function. \n\ngpmin = lambda x: obj.gp(x,spaxels,np.array(wavels))\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=gpmin, maxiter=100)\nres = solver.run(init_params)\ngp_params, state = res\n\ngp_final = make_spec(gp_params,spaxels)\n</pre> %%time # GP log likelihood as objective function.   gpmin = lambda x: obj.gp(x,spaxels,np.array(wavels))  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=gpmin, maxiter=100) res = solver.run(init_params) gp_params, state = res  gp_final = make_spec(gp_params,spaxels) <pre>CPU times: user 2.95 s, sys: 460 ms, total: 3.41 s\nWall time: 3.06 s\n</pre> <p>And with uniform weights:</p> In\u00a0[16]: Copied! <pre># what does a direct sum look like\nuniform = make_spec(init_params,spaxels)\n</pre> # what does a direct sum look like uniform = make_spec(init_params,spaxels) <p>Plot these:</p> In\u00a0[17]: Copied! <pre>fig = plt.figure(figsize=(12.0,8.0))\n\nplt.plot(wavels,uniform,label='Uniform')\nplt.plot(wavels,ext_spec+0.5,label='Pipeline')\n\n\nplt.plot(wavels,tv_final,label='TV-Min',lw=2)\nplt.plot(wavels,l2v_final,label='L2V-Min',lw=2)\nplt.plot(wavels,gp_final,label='GP-Min',lw=2)\n\n# plt.plot(wavels,owl_final,label='OWL',lw=2)\n\n\nplt.legend(fontsize=12)\n</pre> fig = plt.figure(figsize=(12.0,8.0))  plt.plot(wavels,uniform,label='Uniform') plt.plot(wavels,ext_spec+0.5,label='Pipeline')   plt.plot(wavels,tv_final,label='TV-Min',lw=2) plt.plot(wavels,l2v_final,label='L2V-Min',lw=2) plt.plot(wavels,gp_final,label='GP-Min',lw=2)  # plt.plot(wavels,owl_final,label='OWL',lw=2)   plt.legend(fontsize=12) Out[17]: <pre>&lt;matplotlib.legend.Legend at 0x2a01d1250&gt;</pre> <p>So the optimized spectra don't look a lot better than with uniform weights, and none of them closely resemble the pipeline spectrum (which may be a feature, not a bug!).</p> In\u00a0[18]: Copied! <pre>fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(18,6))\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(tv_params)\nax1.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax1.set_title('TV-Min Weights',fontsize=20)\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(l2v_params)\nax2.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax2.set_title('L2V-Min Weights',fontsize=20)\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(gp_params)\nax3.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax3.set_title('GP Weights',fontsize=20)\n\nfor ax in (ax1,ax2,ax3):\n    ax.set_xticks([])\n    ax.set_yticks([])\n</pre> fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(18,6))  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(tv_params) ax1.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax1.set_title('TV-Min Weights',fontsize=20)  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(l2v_params) ax2.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax2.set_title('L2V-Min Weights',fontsize=20)  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(gp_params) ax3.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax3.set_title('GP Weights',fontsize=20)  for ax in (ax1,ax2,ax3):     ax.set_xticks([])     ax.set_yticks([]) <p>Of the three, it looks like L2V (maximum smoothness) has picked out the PSF features nicely, whereas the others have mainly modelled the background.</p>"},{"location":"exploration-saturated/#halo-spectroscopy-of-ceres","title":"Halo Spectroscopy of Ceres\u00b6","text":"<p>Let's apply the halo photometry ideas that worked so successfully in K2, to IFU spectroscopy of a saturated source observed with MIRI: Ceres. The core of its PSF is saturated, but the surrounding spaxels seem to be ok.</p>"},{"location":"exploration-saturated/#now-lets-do-a-tv-min-spectral-extraction","title":"Now let's do a TV-min spectral extraction.\u00b6","text":"<p>We will compare the classic TV-min algorithm from White et al, 2017 to L2 and standard-deviation-optimization algorithms.</p>"},{"location":"exploration-saturated/#visualize-the-weight-map","title":"Visualize the Weight map\u00b6","text":""},{"location":"exploration-unsaturated/","title":"Does halo spectroscopy work on an unsaturated source?","text":"<p>First, import everything we need.</p> In\u00a0[1]: Copied! <pre>import jax.numpy as np\nimport matplotlib.pyplot as plt\nimport numpy as onp\n\nimport jax \n\nfrom astropy.io import fits\n\nfrom glob import glob\n\nimport halospec.objectives as obj\n\nimport jaxopt\n\nfrom matplotlib.widgets import Slider\n\njax.config.update(\"jax_enable_x64\", True)\n\n\n%matplotlib inline\n</pre> import jax.numpy as np import matplotlib.pyplot as plt import numpy as onp  import jax   from astropy.io import fits  from glob import glob  import halospec.objectives as obj  import jaxopt  from matplotlib.widgets import Slider  jax.config.update(\"jax_enable_x64\", True)   %matplotlib inline  In\u00a0[2]: Copied! <pre># ls ../data/MAST_2023-02-09T2333/JWST/\n</pre> # ls ../data/MAST_2023-02-09T2333/JWST/ <p>Which sources did we get in this download?</p> In\u00a0[50]: Copied! <pre>ddir = '../data/MAST_2024-07-05T0101/JWST/'# unsaturated\n# ddir = '../data/MAST_2024-07-05T0131/JWST/' # saturated \ndatasets = glob(ddir+'*')\n# print(datasets)\n\n# figure out which targets are which\nfor j, dataset in enumerate(datasets):\n    try:\n        ifu = glob(dataset+'/*s3d*')\n        hdr = fits.getheader(ifu[0])\n        name = hdr['OBSLABEL']\n        print(j, name)\n    except:\n        print(j,'--')\n</pre> ddir = '../data/MAST_2024-07-05T0101/JWST/'# unsaturated # ddir = '../data/MAST_2024-07-05T0131/JWST/' # saturated  datasets = glob(ddir+'*') # print(datasets)  # figure out which targets are which for j, dataset in enumerate(datasets):     try:         ifu = glob(dataset+'/*s3d*')         hdr = fits.getheader(ifu[0])         name = hdr['OBSLABEL']         print(j, name)     except:         print(j,'--') <pre>0 --\n1 Didymos/MIRI\n2 Didymos/MIRI\n3 Didymos/MIRI Background\n4 Phaethon/MIRI\n5 Didymos/MIRI\n6 Didymos/MIRI Background\n7 Phaethon/MIRI\n8 Phaethon/MIRI\n9 Phaethon/MIRI\n10 Didymos/MIRI Background\n11 Didymos/MIRI\n12 Didymos/MIRI Background\n</pre> In\u00a0[51]: Copied! <pre># dataset = ddir + 'jw01244-o024_t003_miri_ch4-shortmediumlong/'\n\nindex =  7 # Phaethon\ndataset = datasets[index]+'/'\n# print(dataset)\n\nifu = glob(dataset+'*s3d*')\nprint('IFU Filename',ifu[0])\n# print(files)\n\nextracted = glob(dataset+'*x1d*')\nprint('Extracted Spectrum filename',extracted[0])\nextracted_hdr = fits.getheader(extracted[0],ext=1)\n\nhdu = fits.open(ifu[0])\ndata = fits.getdata(ifu[0])\ndata[~onp.isfinite(data)] = 0 # set NaNs to 0\n\nhdr = fits.getheader(ifu[0])\nname = hdr['OBSLABEL']\n\nextracted = glob(dataset+'*x1d*')\nextracted_hdr = fits.getheader(extracted[0],ext=1)\nextracted_data = fits.getdata(extracted[0],ext=1)\nwavels, ext_spec = extracted_data['WAVELENGTH'], extracted_data['FLUX']\next_spec /= onp.nanmedian(ext_spec)\n\nprint('\\nTarget:',name)\n</pre> # dataset = ddir + 'jw01244-o024_t003_miri_ch4-shortmediumlong/'  index =  7 # Phaethon dataset = datasets[index]+'/' # print(dataset)  ifu = glob(dataset+'*s3d*') print('IFU Filename',ifu[0]) # print(files)  extracted = glob(dataset+'*x1d*') print('Extracted Spectrum filename',extracted[0]) extracted_hdr = fits.getheader(extracted[0],ext=1)  hdu = fits.open(ifu[0]) data = fits.getdata(ifu[0]) data[~onp.isfinite(data)] = 0 # set NaNs to 0  hdr = fits.getheader(ifu[0]) name = hdr['OBSLABEL']  extracted = glob(dataset+'*x1d*') extracted_hdr = fits.getheader(extracted[0],ext=1) extracted_data = fits.getdata(extracted[0],ext=1) wavels, ext_spec = extracted_data['WAVELENGTH'], extracted_data['FLUX'] ext_spec /= onp.nanmedian(ext_spec)  print('\\nTarget:',name) <pre>IFU Filename ../data/MAST_2024-07-05T0101/JWST/jw01245-o004_t001_miri_ch4-shortmediumlong/jw01245-o004_t001_miri_ch4-shortmediumlong_s3d.fits\nExtracted Spectrum filename ../data/MAST_2024-07-05T0101/JWST/jw01245-o004_t001_miri_ch4-shortmediumlong/jw01245-o004_t001_miri_ch4-shortmediumlong_x1d.fits\n\nTarget: Phaethon/MIRI\n</pre> In\u00a0[52]: Copied! <pre># one frame\nfig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\n\nax1.imshow(data[0,:,:])\nax1.set_title('Flux')\n\nax2.imshow(data[0,:,:]&gt;0)\nax2.set_title('Positive')\n\nax3.imshow(data[0,:,:]==0)\nax3.set_title('Zero')\n</pre> # one frame fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))  ax1.imshow(data[0,:,:]) ax1.set_title('Flux')  ax2.imshow(data[0,:,:]&gt;0) ax2.set_title('Positive')  ax3.imshow(data[0,:,:]==0) ax3.set_title('Zero') Out[52]: <pre>Text(0.5, 1.0, 'Zero')</pre> <p>(Interactively explore a slice)</p> In\u00a0[53]: Copied! <pre># %matplotlib widget \n# idx0 = 3\n# l = plt.imshow(data[idx0])\n\n# axidx = plt.axes([0.25, 0.01, 0.65, 0.03])\n# slidx = Slider(axidx, 'index', 0, 9, valinit=idx0, valfmt='%d')\n\n# def update(val):\n#     idx = slidx.val\n#     l.set_data(data[int(idx)])\n#     fig.canvas.draw_idle()\n    \n# slidx.on_changed(update)\n\n# plt.show()\n</pre> # %matplotlib widget  # idx0 = 3 # l = plt.imshow(data[idx0])  # axidx = plt.axes([0.25, 0.01, 0.65, 0.03]) # slidx = Slider(axidx, 'index', 0, 9, valinit=idx0, valfmt='%d')  # def update(val): #     idx = slidx.val #     l.set_data(data[int(idx)]) #     fig.canvas.draw_idle()      # slidx.on_changed(update)  # plt.show()  In\u00a0[54]: Copied! <pre>%matplotlib inline\n\n# all frames\nfig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\n\nax1.imshow(onp.median(data,axis=0))\nax1.set_title('Flux')\n\nax2.imshow(onp.median(data,axis=0)&gt;0)\nax2.set_title('Positive')\n\nax3.imshow(onp.min(data,axis=0)&gt;=0)\nax3.set_title('Zero')\n</pre> %matplotlib inline  # all frames fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))  ax1.imshow(onp.median(data,axis=0)) ax1.set_title('Flux')  ax2.imshow(onp.median(data,axis=0)&gt;0) ax2.set_title('Positive')  ax3.imshow(onp.min(data,axis=0)&gt;=0) ax3.set_title('Zero') Out[54]: <pre>Text(0.5, 1.0, 'Zero')</pre> <p>So they are using zero-masking. That's good!</p> In\u00a0[55]: Copied! <pre># ravel pixels\nravelled = np.reshape(data,(data.shape[0],data.shape[1]*data.shape[2]))\nplt.plot(wavels,onp.min(ravelled,axis=1)) # some frames are badly corrected?\n\ngoodframes = (onp.min(ravelled,axis=1)&gt;=0) &amp; (wavels&lt;28.0) # some bad wavels at the long end\n\nplt.plot(wavels[~goodframes],onp.min(ravelled,axis=1)[~goodframes],'-')\n</pre> # ravel pixels ravelled = np.reshape(data,(data.shape[0],data.shape[1]*data.shape[2])) plt.plot(wavels,onp.min(ravelled,axis=1)) # some frames are badly corrected?  goodframes = (onp.min(ravelled,axis=1)&gt;=0) &amp; (wavels&lt;28.0) # some bad wavels at the long end  plt.plot(wavels[~goodframes],onp.min(ravelled,axis=1)[~goodframes],'-') Out[55]: <pre>[&lt;matplotlib.lines.Line2D at 0x2a47151d0&gt;]</pre> In\u00a0[56]: Copied! <pre># frame rejection\ngoodframes = (onp.min(ravelled,axis=1)&gt;=0) &amp; (wavels&lt;28.) # some bad wavels at the long end\n\n# pixel rejection\ngoodpix = (onp.median(data,axis=0)&gt;0.)\n\n# censored data\nnewdata = data[:,goodpix]\nnewdata = newdata[goodframes]\n\nwavels, ext_spec = wavels[goodframes],ext_spec[goodframes]\nprint('Shape of censored data in spectra x spaxels:',newdata.shape)\n</pre> # frame rejection goodframes = (onp.min(ravelled,axis=1)&gt;=0) &amp; (wavels&lt;28.) # some bad wavels at the long end  # pixel rejection goodpix = (onp.median(data,axis=0)&gt;0.)  # censored data newdata = data[:,goodpix] newdata = newdata[goodframes]  wavels, ext_spec = wavels[goodframes],ext_spec[goodframes] print('Shape of censored data in spectra x spaxels:',newdata.shape) <pre>Shape of censored data in spectra x spaxels: (1687, 691)\n</pre> In\u00a0[57]: Copied! <pre>np.sum(goodframes)\n</pre> np.sum(goodframes) Out[57]: <pre>Array(1687, dtype=int64)</pre> <p>Plot some individual spectra, as well as the pipeline and sum:</p> In\u00a0[58]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(1,2,figsize=(15.0,5.0))\nfor j in range(10):\n    spec = newdata[:,j]\n    ax1.plot(wavels,spec/onp.nanmedian(spec))\nax1.set_title('Individual Spaxel Spectra')\nax1.set_xlabel('Wavelength (\u03bcm)')\n    \nflat = onp.sum(newdata,axis=1)\nflat /= onp.nanmedian(flat)\nax2.plot(wavels,flat,label='Total')\nax2.plot(wavels,ext_spec/onp.nanmedian(ext_spec),label='Pipeline')\nplt.legend()\n\nax2.set_title('Total')\nax2.set_xlabel('Wavelength (\u03bcm)')\n</pre> fig, (ax1, ax2) = plt.subplots(1,2,figsize=(15.0,5.0)) for j in range(10):     spec = newdata[:,j]     ax1.plot(wavels,spec/onp.nanmedian(spec)) ax1.set_title('Individual Spaxel Spectra') ax1.set_xlabel('Wavelength (\u03bcm)')      flat = onp.sum(newdata,axis=1) flat /= onp.nanmedian(flat) ax2.plot(wavels,flat,label='Total') ax2.plot(wavels,ext_spec/onp.nanmedian(ext_spec),label='Pipeline') plt.legend()  ax2.set_title('Total') ax2.set_xlabel('Wavelength (\u03bcm)') Out[58]: <pre>Text(0.5, 0, 'Wavelength (\u03bcm)')</pre> <p>Looks like there are a bunch of bad pixels/frames/something. We will probably do a lot better with improved data cleaning.</p> In\u00a0[59]: Copied! <pre>from jaxopt import LBFGS\nmake_spec = obj.make_spec\n</pre> from jaxopt import LBFGS make_spec = obj.make_spec In\u00a0[60]: Copied! <pre>spaxels = np.array(newdata).T # make it a jax array of the right shape\n</pre> spaxels = np.array(newdata).T # make it a jax array of the right shape In\u00a0[61]: Copied! <pre>%%time\n\n# TV-Min - minimize L1 norm of gradient - same as in halo\ntvmin = lambda x: obj.tv(x,1,spaxels) # not using lag so setting it to 1 by lambda function\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=tvmin, maxiter=100)\nres = solver.run(init_params)\ntv_params, state = res\n\ntv_final = make_spec(tv_params,spaxels)\n</pre> %%time  # TV-Min - minimize L1 norm of gradient - same as in halo tvmin = lambda x: obj.tv(x,1,spaxels) # not using lag so setting it to 1 by lambda function  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=tvmin, maxiter=100) res = solver.run(init_params) tv_params, state = res  tv_final = make_spec(tv_params,spaxels) <pre>CPU times: user 2.03 s, sys: 105 ms, total: 2.13 s\nWall time: 2.14 s\n</pre> In\u00a0[62]: Copied! <pre>%%time\n\n# L2V-Min - minimize L2 norm of gradient, ie maximize smoothness\nl2vmin = lambda x: obj.l2v(x,1,spaxels) # not using lag so setting it to 1 by lambda function\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=l2vmin, maxiter=100)\nres = solver.run(init_params)\nl2v_params, state = res\n\nl2v_final = make_spec(l2v_params,spaxels)\n</pre> %%time  # L2V-Min - minimize L2 norm of gradient, ie maximize smoothness l2vmin = lambda x: obj.l2v(x,1,spaxels) # not using lag so setting it to 1 by lambda function  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=l2vmin, maxiter=100) res = solver.run(init_params) l2v_params, state = res  l2v_final = make_spec(l2v_params,spaxels) <pre>CPU times: user 1.58 s, sys: 82.9 ms, total: 1.66 s\nWall time: 1.64 s\n</pre> In\u00a0[63]: Copied! <pre>%%time\n# OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective. \n\nowlmin = lambda x: obj.owl(x,spaxels)\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=owlmin, maxiter=100)\nres = solver.run(init_params)\nowl_params, state = res\n\nowl_final = make_spec(owl_params,spaxels)\n</pre> %%time # OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective.   owlmin = lambda x: obj.owl(x,spaxels)  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=owlmin, maxiter=100) res = solver.run(init_params) owl_params, state = res  owl_final = make_spec(owl_params,spaxels) <pre>CPU times: user 2 s, sys: 91 ms, total: 2.1 s\nWall time: 2.1 s\n</pre> In\u00a0[64]: Copied! <pre>%%time\n# OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective. \n\ngpmin = lambda x: obj.gp(x,spaxels,np.array(wavels))\n\ninit_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)\n\nsolver = jaxopt.LBFGS(fun=gpmin, maxiter=100)\nres = solver.run(init_params)\ngp_params, state = res\n\ngp_final = make_spec(gp_params,spaxels)\n</pre> %%time # OWL - from https://github.com/davidwhogg/OWL using standard deviation as the objective.   gpmin = lambda x: obj.gp(x,spaxels,np.array(wavels))  init_params = 1.0*np.ones(newdata.shape[1]) # shape is (wavels,spaxels)  solver = jaxopt.LBFGS(fun=gpmin, maxiter=100) res = solver.run(init_params) gp_params, state = res  gp_final = make_spec(gp_params,spaxels) <pre>CPU times: user 3.46 s, sys: 270 ms, total: 3.73 s\nWall time: 3.48 s\n</pre> In\u00a0[65]: Copied! <pre># what does a direct sum look like\nuniform = make_spec(init_params,spaxels)\n</pre> # what does a direct sum look like uniform = make_spec(init_params,spaxels) In\u00a0[66]: Copied! <pre>fig = plt.figure(figsize=(12.0,8.0))\n\nplt.plot(wavels,ext_spec/onp.nanmedian(ext_spec),label='Pipeline')\n\n\nplt.plot(wavels,tv_final,label='TV-Min',lw=2)\nplt.plot(wavels,l2v_final,label='L2V-Min',lw=2)\nplt.plot(wavels,gp_final,label='GP-Min',lw=2)\n\n# plt.plot(wavels,owl_final,label='OWL',lw=2)\n# plt.plot(wavels,uniform,label='Uniform')\n\n\n\nplt.legend(fontsize=12)\n</pre> fig = plt.figure(figsize=(12.0,8.0))  plt.plot(wavels,ext_spec/onp.nanmedian(ext_spec),label='Pipeline')   plt.plot(wavels,tv_final,label='TV-Min',lw=2) plt.plot(wavels,l2v_final,label='L2V-Min',lw=2) plt.plot(wavels,gp_final,label='GP-Min',lw=2)  # plt.plot(wavels,owl_final,label='OWL',lw=2) # plt.plot(wavels,uniform,label='Uniform')    plt.legend(fontsize=12) Out[66]: <pre>&lt;matplotlib.legend.Legend at 0x2a8b14090&gt;</pre> <p>So the optimized spectra don't look a lot better than with uniform weights, and none of them closely resemble the pipeline spectrum (which may be a feature, not a bug!).</p> In\u00a0[67]: Copied! <pre>fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(18,6))\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(tv_params)\nax1.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax1.set_title('TV-Min Weights',fontsize=20)\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(l2v_params)\nax2.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax2.set_title('L2V-Min Weights',fontsize=20)\n\nweightmap = onp.nan*goodpix\nweightmap[goodpix] = obj.softmax(gp_params)\nax3.imshow(np.log10(weightmap),cmap=plt.cm.seismic)\nax3.set_title('GP Weights',fontsize=20)\n\nfor ax in (ax1,ax2,ax3):\n    ax.set_xticks([])\n    ax.set_yticks([])\n</pre> fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(18,6))  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(tv_params) ax1.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax1.set_title('TV-Min Weights',fontsize=20)  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(l2v_params) ax2.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax2.set_title('L2V-Min Weights',fontsize=20)  weightmap = onp.nan*goodpix weightmap[goodpix] = obj.softmax(gp_params) ax3.imshow(np.log10(weightmap),cmap=plt.cm.seismic) ax3.set_title('GP Weights',fontsize=20)  for ax in (ax1,ax2,ax3):     ax.set_xticks([])     ax.set_yticks([]) <p>Not sure what to make of this - of the three, the GP has really nailed putting the weights on the target; whereas the others seem to have spread out across the background, but nevertheless match the pipeline better.</p>"},{"location":"exploration-unsaturated/#does-halo-spectroscopy-work-on-an-unsaturated-source","title":"Does halo spectroscopy work on an unsaturated source?\u00b6","text":"<p>If we want to believe halo spectroscopy results on a saturated source, we should first verify that it gives satisfactory results for an unsaturated source. Therefore let us look at Phaethon, not expected to be saturated, and try the various optimized weight spectroscopy methods.</p>"},{"location":"exploration-unsaturated/#visualize-a-slice","title":"Visualize a slice\u00b6","text":""},{"location":"exploration-unsaturated/#now-lets-do-a-tv-min-spectral-extraction","title":"Now let's do a TV-min spectral extraction.\u00b6","text":"<p>We will compare the classic TV-min algorithm from White et al, 2017 to L2 and standard-deviation-optimization algorithms.</p>"},{"location":"exploration-unsaturated/#visualize-the-weight-map","title":"Visualize the Weight map\u00b6","text":""}]}